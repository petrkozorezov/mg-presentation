title: Автоматный подход при разработке бизнес-логики платёжного процессинга
class: animation-fade
layout: true

---

class: center, middle

# {{title}}

---

layout: true

## Бизнес логика процессинга RBK Money

---

.center[![payment_tech_interact_flow](uml/payment_tech_interact_flow.svg)]

.center[![payment_money_flow](uml/payment_money_flow.svg)]

---

.center[![payment_flow](uml/payment_flow.svg)]

---

layout: false

## Какие требования стояли перед процессингом

--

Принимaть платежи:

 - консистентность

--

 - горизонтальная масштабируемость

--

 - отказоустойчивость

---

## Платёж — это конечный автомат

.center[.bottom[![:scale 70%](uml/payment_fsm.svg)]]

---

## Что решили сделать

  Сервис для обработки конечных автоматов — **machinegun**

  Идея в том, чтобы собрать в одном месте основную сложность

  Какие у него задачи:
  - хранение стейта
  - взаимодействие со stateless процессорами
  - распределённая отказоустойчивая обработка
  - обработка таймеров

---

## Общая архитектура

.center[.bottom[![](uml/mg_arch.svg)]]

---

## Общая архитектура (что уже сделали)

.center[.bottom[![](uml/mg_arch_real.svg)]]

---

## Что такое автомат (machine) в представление MG

```erlang
-type machine() ::
  {
    History  :: [event()],
    AuxState :: term(),
    Timer    :: timestamp()
  }
```

---

layout: true

## Взаимодействие с процессором

---

### Запуск машины

.center[.bottom[![](uml/mg_start.svg)]]

---

### Взаимодействие при обработке запроса

.center[.bottom[![](uml/mg_call.svg)]]

---

### Взаимодействие при обработке таймера

.center[.bottom[![](uml/mg_timer.svg)]]

---

layout: false
layout: true

## Пример: проведение платежа

---

### Flow платежа

.center[![](uml/payment_flow.svg)]


---

### Создание платежа

.center[.bottom[![](uml/mg_payment_start.svg)]]

---

### Инспекция внешним антифродом

.center[.bottom[![](uml/mg_payment_af.svg)]]

---

### Авторизация в банке

.center[.bottom[![:scale 80%](uml/mg_payment_auth.svg)]]

---

### Уведомление мёрчанта

.center[.bottom[![](uml/mg_payment_notify.svg)]]

---

layout: false
layout: true

## Кратко о том, как оно работает

---

### Представление машины внутри эрланга

 - Машина — gen_server
 - Машины лениво загружаются и выгружаются
 - Любой запрос к машине gen_server:call

---

### Представление в базе:

2 таблички:

 - machines: {id, state, timer, events_range}
 - events: {{machine_id, id}, ts, payload}

---

### Таймеры

 - ts таймера и status — это вторичные ключи в риаке в таблице machines
 - процесс поллер раз в секунду делает выборку по вторичному ключу N готовых таймеров

---

layout: false

## Что в результате

--

 - это работает :)

--

 - не  дописали :( (распределённую версия готова на 50%)

--

 - удобно использовать только в том случае, когда автоматов много, и они маленькие

--

 - писать логику довольно сложно, но можно забыть про множество проблем (обработка ошибок, работа с базой, реализация таймеров и тд)

--

 - к риаку никаких вопросов (~100kk записей)

--

 - основные проблемы были от таймеров и обработки ошибок от процессора

--

 - проект открыли, но пока его собрать без внутренней инфраструктуры не получится

---

class: center, middle

## Вопросы?
